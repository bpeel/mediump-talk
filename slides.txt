SVG: title-page.svg
---
# Overview

* Introduction
* History
* Examples
* Current status
* Future
* Questions

---

# What is mediump?

---

* Only in GLSL ES
* Available since the first version of OpenGL ES.
* Used to tell the driver an operation in a shader can be done with lower precision.
* Some hardware can take advantage of this to trade off precision for speed.

---

* For example, an operation can be done with a 16-bit float:

SVG: precision-diagram.svg

---

* GLSL ES has three available precisions:
  * lowp, mediump and highp
  * The spec specifies a minimum precision for each of these.
  * highp needs 16-bit fractional part.
    * It will probably end up being a single-precision float.
  * mediump needs 10-bit fractional part.
    * This can be represented as a half float.
  * lowp has enough precision to store 8-bit colour channels.

---

* The precision does not affect the visible storage of a variable.
  * For example a mediump float will still be stored as 32-bit in a UBO.
  * Only operations are affected.
* The precision requirements are only a minimum.
  * Therefore a valid implementation could be to just ignore the precision and do every operation at highp.
  * This is effectively what Mesa currently does.

---

* The precision for a variable can be specified directly:

```
uniform mediump vec3 rect_color;
```

* Or it can be specified as a global default for each type:

```
precision mediump float;
uniform vec3 rect_color;
```

---

* The compiler specifies global defaults for most types except floats in the fragment shader.
* In GLSL ES 1.00 high precision support in fragment shaders is optional.

---

* The precision of operands to an operation determine the precision of the operation.
* Almost works like automatic float to double promotion in C.

SVG: simple-multiplication.svg*

---

* Another example

SVG: mix-multiplication.svg*

---

* Corner case
  * Some things don’t have a precision, eg constants.

SVG: constant-no-precision.svg*

---

* Extreme corner case
  * Sometimes none of the operands have a precision.

SVG: no-operand-has-precision.svg*

---

# What does Mesa currently do?

---

* Mesa already has code to parse the precision qualiers and store them in the IR tree.
* These currently aren’t used for anything except to check for compile-time errors.
  * For example redeclaring a variable with a different precision.
* In desktop GL, the precision is always set to NONE.

---

* The precision usually doesn’t form part of the glsl_type.
* Instead it is stored out-of-band as part of the ir_variable.

---
```
enum {
   GLSL_PRECISION_NONE = 0,
   GLSL_PRECISION_HIGH,
   GLSL_PRECISION_MEDIUM,
   GLSL_PRECISION_LOW
};
```
---

```
#include var-precision.cpp
```

---

* However this gets complicated for structs because members can have their own precision.

```
uniform block {
	mediump vec3 just_a_color;
	highp mat4 important_matrix;
} things;
```

* In that case the precision does end up being part of the glsl_type.

---

# The plan

---

* The idea is to lower mediump operations to float16 types in NIR.
* We want to lower the actual operations instead of the variables.
* This needs to be done at a high level in order to implement the spec rules.

---

* Aiming specifically to make this work on the Freedreno driver.
* Most of the work is reusable for any driver though.
* Currently this is done as a pass over the IR representation.

---

SVG: simple-division.svg*

---

* We only want to lower the division operation without changing the type of the variables.
* The lowering pass will add a conversion to float16 around the variable dereferences and then add a conversion back to float32 after the division.
* This minimises the modifications to the IR.

---

* IR tree before lowering pass

SVG: ir-tree.svg*

---

* Lowering pass finds sections of the tree involving only mediump/lowp operations.
* Adds f2f16 conversion after variable derefs
* Adds f2f32 conversion at root of lowered branch

---

* IR tree after lowering pass

SVG: ir-tree-after.svg*

---

# Questions?
